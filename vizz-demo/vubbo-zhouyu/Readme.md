# vubbo-zhouyu

这里打算写一个简单的dubbo，跟着b站的周瑜架构师学习

我们要先理清楚整个架构

1. 服务提供者向注册中心登记接口名、主机的地址和端口
2. 服务消费者从注册中心拉取服务提供者列表
3. 服务消费者通过列表去调取服务提供者，这过程需要以下信息，前三个写在接口里写在注册中心，第四个是自己决定的
   1. 接口名
   2. 方法名
   3. 方法参数类型列表
   4. 方法参数值列表



然后每个角色 都要各司其职

1. 服务提供者
   1. 提供服务的接口
   2. 提供实现类
   3. 注册服务（注册中心、**本地**）
   4. 暴露服务（启动tomcat、NettyServer从而接收以及处理请求）
2. 注册中心（zk、redis等）
   1. 保存服务名与服务器地址映射关系
   2. 服务地址变动主动通知服务消费者
3. 服务消费者
   1. 从注册中心获取信息并缓存
   2. 通过获得的信息进行调用



这里提到了本地注册，是做什么用的？

至少从上面来看，消费者有一个Invocation对象包装了：接口名、方法名、方法参数类型列表、方法参数值列表等信息，但是这个信息传送到提供者这边时，不一定能准确找到对应的服务，因为压根就不知道这个接口由哪个类实现，或者是多个实现到底调谁，所以需要在提供者这边缓存一个列表，只在这个列表中寻找。找到后，再反射啥的，只要能调用就行。

这么一说，想起了分布式事务框架。分布式事务框架也存在这种场景，我们的做法是将子事务的正交易反交易方法都缓存一份，然后回调的时候直接去缓存里面找、调取。

提供者有多个实现类？这种场景其实应该是有多个版本，可以用version，而且只有LocalRegister登记的服务才能被调用。

追问：dubbo里面有这个缓存吗？key是不是url？



### ProxyConsumerApp

http方式实现了，但是很不优雅，我们想像dubbo一样用reference机制，然后直接用接口调用某个方法。

记住一句话：**如果只有接口，那么就只能生成一个代理对象，是不能生成实体对象的。**

所以我们用动态代理，来实现这个服务的调用。

如果这个代理对象成为一个bean，那么就可以交给spring来管理，这也就能和spring联动。



### 注册中心的编写

以上我的消费者采用的hostname和port都是写死的，理论上这些值应该从注册中心拿到。于是现在，我们开始写注册中心的逻辑

注册中心不能只是一个类，否则无法在两个进程中通信



### Netty

这边netty代码有问题跑不起来，暂不研究了。

netty是基于socket的，不是基于http的。同时如果提供者换了netty，那么消费端也需要换为netty。





容错

直接开消费者，会报错，理论上没有我们应该重试。



MOCK